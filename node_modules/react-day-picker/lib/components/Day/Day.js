var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import * as React from 'react';
import { isSameDay, isSameMonth } from 'date-fns';
import { useDayPicker, useNavigation } from '../../hooks';
import { UIElement } from '../../types';
import { getModifiersStatus } from './utils/getModifiersStatus';
/**
 * Render the content of a date cell, as a button or span element according to
 * its modifiers. Attaches the event handlers from DayPicker context, and manage the
 * focused date.
 */
export function Day(props) {
    var el = React.useRef(null);
    var context = useDayPicker();
    var labels = context.labels, formatters = context.formatters, locale = context.locale, showOutsideDays = context.showOutsideDays;
    var _a = useNavigation(), currentMonth = _a.currentMonth, focusedDay = _a.focusedDay;
    var displayMonth = props.displayMonth, date = props.date;
    var formatDay = formatters.formatDay;
    // Do not return anything if the date is not in the range
    var modifiers = getModifiersStatus(date, displayMonth, context);
    React.useEffect(function () {
        var _a;
        if (!focusedDay)
            return;
        if (isSameDay(focusedDay, date))
            (_a = el === null || el === void 0 ? void 0 : el.current) === null || _a === void 0 ? void 0 : _a.focus();
    }, [focusedDay]);
    if (modifiers.hidden)
        return React.createElement("span", null);
    if (modifiers.outside && !showOutsideDays)
        return React.createElement("span", null);
    var ariaLabel = labels.dayLabel(date, modifiers, { locale: locale });
    var ariaPressed = modifiers.interactive ? modifiers.selected : undefined;
    var disabled = modifiers.disabled;
    // #region TabIndex
    var tabIndex = !modifiers.interactive ? undefined : -1;
    if (modifiers.interactive) {
        if ((focusedDay && isSameDay(date, focusedDay)) ||
            (isSameMonth(date, currentMonth) && date.getDate() === 1)) {
            tabIndex = 0;
        }
    }
    // #endregion
    // #region EventHandlers
    var onDayBlur = context.onDayBlur, onDayClick = context.onDayClick, onDayFocus = context.onDayFocus, onDayKeyDown = context.onDayKeyDown;
    var handleClick = function (e) {
        onDayClick(date, modifiers, e);
    };
    var handleFocus = function (e) {
        onDayFocus(date, modifiers, e);
    };
    var handleBlur = function (e) {
        onDayBlur(date, modifiers, e);
    };
    var handleKeyDown = function (e) {
        onDayKeyDown(date, modifiers, e);
    };
    var handleKeyUp = function (e) {
        var _a;
        (_a = props.onDayKeyUp) === null || _a === void 0 ? void 0 : _a.call(props, date, modifiers, e);
    };
    var handleMouseEnter = function (e) {
        var _a;
        (_a = props.onDayMouseEnter) === null || _a === void 0 ? void 0 : _a.call(props, date, modifiers, e);
    };
    var handleMouseLeave = function (e) {
        var _a;
        (_a = props.onDayMouseLeave) === null || _a === void 0 ? void 0 : _a.call(props, date, modifiers, e);
    };
    var handleTouchCancel = function (e) {
        var _a;
        (_a = props.onDayTouchCancel) === null || _a === void 0 ? void 0 : _a.call(props, date, modifiers, e);
    };
    var handleTouchEnd = function (e) {
        var _a;
        (_a = props.onDayTouchEnd) === null || _a === void 0 ? void 0 : _a.call(props, date, modifiers, e);
    };
    var handleTouchMove = function (e) {
        var _a;
        (_a = props.onDayTouchMove) === null || _a === void 0 ? void 0 : _a.call(props, date, modifiers, e);
    };
    var handleTouchStart = function (e) {
        var _a;
        (_a = props.onDayTouchStart) === null || _a === void 0 ? void 0 : _a.call(props, date, modifiers, e);
    };
    // #endregion
    // #region ClassNames
    // TODO: move in an external utility?
    var classNames = context.classNames, modifiersClassNames = context.modifiersClassNames, modifierPrefix = context.modifierPrefix;
    var buttonClassNames = [classNames[UIElement.Day]];
    Object.keys(modifiers)
        .filter(function (modifier) { return Boolean(modifiers[modifier]); })
        .forEach(function (modifier) {
        if (modifiersClassNames === null || modifiersClassNames === void 0 ? void 0 : modifiersClassNames[modifier]) {
            // Use class name coming from props
            buttonClassNames.push(modifiersClassNames[modifier]);
        }
        else {
            // Create a class name with the prefix
            buttonClassNames.push("" + modifierPrefix + modifier);
        }
    });
    // #endregion
    // #region Styles
    // TODO: move to an external utility?
    var styles = context.styles, modifiersStyles = context.modifiersStyles;
    var style = __assign({}, styles === null || styles === void 0 ? void 0 : styles[UIElement.Day]);
    if (styles) {
        Object.keys(modifiers).forEach(function (modifier) {
            style = __assign(__assign({}, style), styles[modifier]);
        });
    }
    if (modifiersStyles) {
        Object.keys(modifiers).forEach(function (modifier) {
            style = __assign(__assign({}, style), modifiersStyles[modifier]);
        });
    }
    // #endregion
    var Component = modifiers.interactive ? 'button' : 'span';
    return (React.createElement(Component, { ref: el, "aria-label": ariaLabel, "aria-pressed": ariaPressed, disabled: disabled, style: style, className: buttonClassNames.join(' '), tabIndex: tabIndex, onClick: handleClick, onFocus: handleFocus, onBlur: handleBlur, onKeyDown: handleKeyDown, onKeyUp: handleKeyUp, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, onTouchCancel: handleTouchCancel, onTouchEnd: handleTouchEnd, onTouchMove: handleTouchMove, onTouchStart: handleTouchStart }, formatDay(date, { locale: locale })));
}
//# sourceMappingURL=Day.js.map