declare type Static = boolean;
declare type Declarative = Record<string, any>;
declare type Imperative<T> = (args: T) => Promise<Static | Declarative>;
declare type FieldImperative<T> = (args: T) => Promise<Static>;
declare type Context = any;
declare type ListAccessArgs = {
    operation: keyof ListAccess;
    listKey: string;
    authentication: any;
    gqlName: string;
    context: Context;
    originalInput?: any;
    itemId?: any;
    itemIds?: any;
};
declare type FieldAccessArgs = {
    operation: keyof FieldAccess;
    listKey: string;
    fieldKey: string;
    originalInput: any;
    existingItem: any;
    authentication: any;
    gqlName: string;
    itemId: any;
    itemIds: any;
    context: Context;
};
declare type AuthAccessArgs = {
    operation: keyof AuthAccess;
    listKey: string;
    authentication: any;
    gqlName: string;
    context: Context;
};
declare type CustomAccessArgs = {
    item: any;
    args: any;
    context: Context;
    info: any;
    authentication: any;
    gqlName: string;
};
declare type ListAccess = {
    create: Static | Declarative | Imperative<ListAccessArgs>;
    read: Static | Declarative | Imperative<ListAccessArgs>;
    update: Static | Declarative | Imperative<ListAccessArgs>;
    delete: Static | Declarative | Imperative<ListAccessArgs>;
};
declare type AuthAccess = {
    auth: Static | Declarative | Imperative<AuthAccessArgs>;
};
declare type FieldAccess = {
    create: Static | FieldImperative<FieldAccessArgs>;
    read: Static | FieldImperative<FieldAccessArgs>;
    update: Static | FieldImperative<FieldAccessArgs>;
};
declare type CustomAccess = Static | Declarative | Imperative<CustomAccessArgs>;
export declare function parseCustomAccess<SN extends string>({ defaultAccess, access, schemaNames, }: {
    defaultAccess: CustomAccess;
    access?: Partial<Record<SN, CustomAccess>> | CustomAccess;
    schemaNames: SN[];
}): Record<SN, CustomAccess> & {
    internal: true;
};
declare type ListAuthAccess = ListAccess & AuthAccess;
export declare function parseListAccess<SN extends string>({ listKey, defaultAccess, access, schemaNames, }: {
    listKey: string;
    defaultAccess: ListAccess['read'];
    access?: Partial<Record<SN, Partial<ListAuthAccess> | ListAccess['read']>> | Partial<ListAuthAccess> | ListAccess['read'];
    schemaNames: SN[];
}): Record<SN, ListAuthAccess> & {
    internal: Record<"update" | "create" | "delete" | "read" | "auth", true>;
};
export declare function parseFieldAccess<SN extends string>({ listKey, fieldKey, defaultAccess, access, schemaNames, }: {
    listKey: string;
    fieldKey: string;
    defaultAccess: FieldAccess['read'];
    access?: Partial<Record<SN, Partial<FieldAccess> | FieldAccess['read']>> | Partial<FieldAccess> | FieldAccess['read'];
    schemaNames: SN[];
}): Record<SN, FieldAccess> & {
    internal: Record<"update" | "create" | "read", true>;
};
export declare function validateCustomAccessControl({ item, args, context, info, access, authentication, gqlName, }: {
    access: CustomAccess;
} & CustomAccessArgs): Promise<boolean | Record<string, any>>;
export declare function validateListAccessControl({ access, listKey, operation, authentication, originalInput, gqlName, itemId, itemIds, context, }: {
    access: ListAccess;
} & ListAccessArgs): Promise<boolean | Record<string, any>>;
export declare function validateFieldAccessControl({ access, listKey, fieldKey, originalInput, existingItem, operation, authentication, gqlName, itemId, itemIds, context, }: {
    access: FieldAccess;
} & FieldAccessArgs): Promise<boolean>;
export declare function validateAuthAccessControl({ access, listKey, authentication, gqlName, context, }: {
    access: AuthAccess;
} & Omit<AuthAccessArgs, 'operation'>): Promise<boolean | Record<string, any>>;
export {};
